{"ast":null,"code":"const path = require(\"path\");\n\nconst fs = require(\"fs\");\n\nconst dirPath = path.join(__dirname, \"posts_md\");\nlet postlist = [];\n\nconst getPosts = () => {\n  fs.readdir(dirPath, (err, files) => {\n    if (err) {\n      return console.log(\"Failed to list content of directory: \" + err);\n    }\n\n    files.forEach((file, i) => {\n      let obj = {};\n      let post;\n      fs.readFile(`${dirPath}/${file}`, \"utf8\", (err, contents) => {\n        const getMetadataIndicies = (acc, elem, i) => {\n          if (/^---/.test(elem)) {\n            acc.push(i);\n          }\n\n          return acc;\n        };\n\n        const parseMetadata = _ref => {\n          let {\n            lines,\n            metadataIndicies\n          } = _ref;\n\n          if (metadataIndicies.length > 0) {\n            let metadata = lines.slice(metadataIndicies[0] + 1, metadataIndicies[1]);\n            metadata.forEach(line => {\n              obj[line.split(\": \")[0]] = line.split(\": \")[1];\n            });\n            return obj;\n          }\n        };\n\n        const parseContent = _ref2 => {\n          let {\n            lines,\n            metadataIndicies\n          } = _ref2;\n\n          if (metadataIndicies.length > 0) {\n            lines = lines.slice(metadataIndicies[1] + 1, lines.length);\n          }\n\n          return lines.join(\"\\n\");\n        };\n\n        const lines = contents.split(\"\\n\");\n        const metadataIndicies = lines.reduce(getMetadataIndicies, []);\n        const metadata = parseMetadata({\n          lines,\n          metadataIndicies\n        });\n        const content = parseContent({\n          lines,\n          metadataIndicies\n        });\n        post = {\n          id: i + 1,\n          title: metadata.title ? metadata.title : \"No title given\",\n          author: metadata.author ? metadata.author : \"No author given\",\n          date: metadata.date ? metadata.date : \"No title date\",\n          content: content ? content : \"No content given\"\n        };\n        postlist.push(post);\n\n        if (i === files.length - 1) {\n          let data = JSON.stringify(postlist);\n          fs.writeFileSync(\"src/posts.json\", data);\n        }\n      });\n    });\n  });\n  return;\n};\n\ngetPosts();","map":{"version":3,"sources":["D:/programmering/react projects/min-hemsida-1/frontend/src/Post1.js"],"names":["path","require","fs","dirPath","join","__dirname","postlist","getPosts","readdir","err","files","console","log","forEach","file","i","obj","post","readFile","contents","getMetadataIndicies","acc","elem","test","push","parseMetadata","lines","metadataIndicies","length","metadata","slice","line","split","parseContent","reduce","content","id","title","author","date","data","JSON","stringify","writeFileSync"],"mappings":"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","sourcesContent":["const path = require(\"path\");\r\nconst fs = require(\"fs\");\r\n\r\nconst dirPath = path.join(__dirname, \"posts_md\");\r\n\r\nlet postlist = [];\r\n\r\nconst getPosts = () => {\r\n  fs.readdir(dirPath, (err, files) => {\r\n    if(err) {\r\n      return console.log(\"Failed to list content of directory: \" + err);\r\n    }\r\n    \r\n\r\n    files.forEach((file, i) => {\r\n      let obj = {};\r\n      let post \r\n      fs.readFile(`${dirPath}/${file}`, \"utf8\", (err, contents) => {\r\n        const getMetadataIndicies = (acc, elem, i) => {\r\n          if(/^---/.test(elem)) {\r\n            acc.push(i)\r\n          }\r\n          return acc\r\n        }\r\n        const parseMetadata = ({lines, metadataIndicies}) => {\r\n          if (metadataIndicies.length > 0){\r\n            let metadata = lines.slice(metadataIndicies[0] + 1, metadataIndicies[1])\r\n            metadata.forEach(line => {\r\n              obj[line.split(\": \")[0]] =  line.split(\": \")[1]\r\n            })\r\n            return obj\r\n          }\r\n        }\r\n        const parseContent = ({lines, metadataIndicies}) => {\r\n          if (metadataIndicies.length > 0) {\r\n            lines = lines.slice(metadataIndicies[1] + 1, lines.length)\r\n          }\r\n          return lines.join(\"\\n\")\r\n        }\r\n        const lines = contents.split(\"\\n\");\r\n        const metadataIndicies = lines.reduce(getMetadataIndicies, []);\r\n        const metadata = parseMetadata({lines, metadataIndicies})\r\n        const content = parseContent({lines, metadataIndicies})\r\n        post = {\r\n          id: i + 1,\r\n          title: metadata.title ? metadata.title : \"No title given\",\r\n          author: metadata.author ? metadata.author : \"No author given\",\r\n          date: metadata.date ? metadata.date : \"No title date\",\r\n          content: content ? content : \"No content given\",\r\n        }\r\n        postlist.push(post)\r\n        if(i === files.length -1){\r\n          let data = JSON.stringify(postlist)\r\n          fs.writeFileSync(\"src/posts.json\", data)\r\n        }\r\n      })\r\n    })\r\n  })\r\n  return\r\n}\r\n\r\ngetPosts()\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}